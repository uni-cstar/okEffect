package unics.okeffect.compiler;

import com.google.auto.service.AutoService;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

import java.io.IOException;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.MirroredTypesException;
import javax.lang.model.type.TypeMirror;

import unics.generator.okcompiler.BaseProcessor;
import unics.generator.okcompiler.DroidMethodUtils;
import unics.okeffect.annotation.EffectLayout;


@AutoService(Processor.class)
public class EffectLayoutCompiler extends BaseProcessor {

    private static final String TAG = "okEffectCompiler";

    private static final String CLASS_JAVA_DOC = "Generated by okEffectCompiler. Do not edit it!\nCreate by luochao";
    private static final String DI_PACKAGE_NAME = "unics.okeffect";

    @Override
    protected String getTag() {
        return TAG;
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        final Set<String> annotationTypes = new LinkedHashSet<>();
        annotationTypes.add(EffectLayout.class.getCanonicalName());
        return annotationTypes;
    }

    @Override
    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {
        Set<? extends Element> elements = roundEnvironment.getElementsAnnotatedWith(EffectLayout.class);
        if (elements == null || elements.isEmpty()) {
            printMessage("process interrupt:elements is empty.");
            return true;
        }
        printDividerMessage("LeanbackLayoutProcessor process START");

        ParseResult parseResult = parseParams(elements);
        if (parseResult.viewClassSet == null || parseResult.viewClassSet.size() == 0) {
            printMessage("process interrupt:elements is empty.");
            return true;
        }

        try {
            generateClasses(parseResult);
        } catch (IllegalAccessException e) {
            printErrorMessage("IllegalAccessException occurred when generating class file.");
            e.printStackTrace();
        } catch (IOException e) {
            printErrorMessage("IOException occurred when generating class file.");
            e.printStackTrace();
        }
        printDividerMessage("LeanbackLayoutProcessor process END");
        return true;
    }

    private void generateClasses(ParseResult parseResult) throws IllegalAccessException, IOException {
        printMessage(String.format("准备生成%d个文件", parseResult.viewClassSet.size()));
        for (String clazz : parseResult.viewClassSet) {
            int lastDotIndex = clazz.lastIndexOf(".");
            String superPackageName = clazz.substring(0, lastDotIndex);
            String superClassName = clazz.substring(lastDotIndex + 1);
            String className = parseResult.classPrefix + superClassName + parseResult.classSuffix;

            printMessage(String.format("正在生成 %s ====>  %s", clazz, className));

            TypeSpec.Builder typeBuilder = TypeSpec.classBuilder(className)
                    .addJavadoc(CLASS_JAVA_DOC)
                    .addModifiers(Modifier.PUBLIC)
                    .superclass(ClassName.get(superPackageName, superClassName))
                    .addSuperinterface(ClassName.get(DI_PACKAGE_NAME, "EffectLayoutDelegate.DI"))
                    .addField(ClassName.get(DI_PACKAGE_NAME, "EffectLayoutDelegate"), "mDelegate", Modifier.PRIVATE, Modifier.FINAL);

            generateMethods(typeBuilder, clazz);

            JavaFile javaFile = JavaFile.builder(DI_PACKAGE_NAME, typeBuilder.build()).build();
            javaFile.writeTo(filer);
        }
    }

    private CodeBlock constructorCode() {
        return CodeBlock.builder()
                .addStatement("super(context, attrs, defStyleAttr)")
                .add(CodeBlock.builder()
                        .addStatement("//这两句代码不能合并执行，否则在setup中添加了view，会导致onViewAdd的回调，此时mDelegate还未创建成功")
                        .addStatement("mDelegate = new EffectLayoutDelegate(this, this)")
                        .addStatement("mDelegate.setup(context, attrs, defStyleAttr)")
                        .addStatement("//修改绘制顺序")
                        .addStatement("setChildrenDrawingOrderEnabled(true)")
                        .build())
                .build();
    }

    private void generateMethods(TypeSpec.Builder typeBuilder, String clazz) {
        DroidMethodUtils.viewConstructorOverloads(typeBuilder, clazz, constructorCode(), "R.attr.effectDrawableStyle");
        delegateDIImpl(typeBuilder, clazz);
        getChildDrawingOrder(typeBuilder, clazz);
        onMeasure(typeBuilder, clazz);
        onViewAdded(typeBuilder, clazz);
        onViewRemoved(typeBuilder, clazz);
        onFocusChanged(typeBuilder, clazz);
    }

    private void delegateDIImpl(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec superGetChildDrawingOrder = MethodSpec.methodBuilder("superGetChildDrawingOrder")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(int.class, "childCount")
                .addParameter(int.class, "drawingPosition")
                .addStatement("return super.getChildDrawingOrder(childCount, drawingPosition)")
                .returns(int.class)
                .build();
        typeBuilder.addMethod(superGetChildDrawingOrder);

        MethodSpec superOnMeasure = MethodSpec.methodBuilder("superOnMeasure")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(int.class, "widthMeasureSpec")
                .addParameter(int.class, "heightMeasureSpec")
                .addStatement("super.onMeasure(widthMeasureSpec, heightMeasureSpec)")
                .build();
        typeBuilder.addMethod(superOnMeasure);
    }

    private void getChildDrawingOrder(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec methodSpec = DroidMethodUtils.getChildDrawingOrderSignature()
                .addStatement("return mDelegate.getChildDrawingOrder(childCount, drawingPosition)")
                .returns(int.class)
                .build();
        typeBuilder.addMethod(methodSpec);
    }

    private void onMeasure(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec methodSpec = DroidMethodUtils.onMeasureSignature()
                .addStatement("mDelegate.onMeasure(widthMeasureSpec, heightMeasureSpec)")
                .build();
        typeBuilder.addMethod(methodSpec);
    }

    private void onViewAdded(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec onViewRemoved = DroidMethodUtils.onViewAddedSignature()
                .addStatement("super.onViewRemoved(child)")
                .addStatement("mDelegate.onViewAdded(child)")
                .build();
        typeBuilder.addMethod(onViewRemoved);
    }

    private void onViewRemoved(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec onViewRemoved = DroidMethodUtils.onViewRemovedSignature()
                .addStatement("super.onViewRemoved(child)")
                .addStatement("mDelegate.onViewRemoved(child)")
                .build();
        typeBuilder.addMethod(onViewRemoved);
    }

    private void onFocusChanged(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec onViewRemoved = DroidMethodUtils.onFocusChangedSignature()
                .addStatement("super.onFocusChanged(gainFocus, direction, previouslyFocusedRect)")
                .addStatement("mDelegate.onFocusChanged(gainFocus, direction, previouslyFocusedRect)")
                .build();
        typeBuilder.addMethod(onViewRemoved);
    }

    private ParseResult parseParams(Set<? extends Element> elements) {
        ParseResult result = new ParseResult();
        for (Element element : elements) {
            checkAnnotationValid(element, EffectLayout.class);
            TypeElement classElement = (TypeElement) element;
            // 获取该注解的值
            EffectLayout badgeAnnotation = classElement.getAnnotation(EffectLayout.class);
            result.classPrefix = badgeAnnotation.classPrefix();
            result.classSuffix = badgeAnnotation.classSuffix();
            try {
                badgeAnnotation.value();
            } catch (MirroredTypesException e) {
                e.printStackTrace();
                printMessage("parseParams error:" + e);
                List<? extends TypeMirror> typeMirrors = e.getTypeMirrors();
                for (TypeMirror typeMirror : typeMirrors) {
                    DeclaredType classTypeMirror = (DeclaredType) typeMirror;
                    TypeElement classTypeElement = (TypeElement) classTypeMirror.asElement();
                    String qualifiedName = classTypeElement.getQualifiedName().toString();
                    result.viewClassSet.add(qualifiedName);
                }
            }
        }
        return result;
    }

    class ParseResult {
        String classPrefix;
        String classSuffix;

        Set<String> viewClassSet = new HashSet<>();
    }

}